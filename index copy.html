<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>TiltDJ(test)</title>
    <!-- <script src="https://zimjs.org/cdn/1.3.2/createjs.js"></script>
    <script src="https://zimjs.org/cdn/cat/00/zim.js"></script>
    <script src="header.js"></script>     -->
    <script type="module">
      import zim from "https://zimjs.org/cdn/016/zim";
      new Frame({
        scaling: FIT,
        width: 1500,
        height: 2896,
        color: dark,
        outerColor: dark,
        ready: ready,
        assets: ["1.mp3", "2.mp3", "3.mp3", "4.mp3", "bg.png"],
        path: "assets/",
        sensors: true,
      });

      function ready() {
        const bg = new Pic("bg.png").alp(0.6).center();
        const audio1 = new Aud("1.mp3");
        const audio2 = new Aud("2.mp3");
        const audio3 = new Aud("3.mp3");
        const synth = new Synth();
        const ball2 = new Circle(20, "#f5776e")
          .center()
          .wiggle("y", H / 2, 50, H / 2, 1, 3);
        const ball1 = new Circle(20, "#89defa")
          .center()
          .wiggle("x", W / 2, 50, W / 2, 1, 3);
        let tone;

        init(true);

        function init(yes) {
          const errorPane = new Pane("SENSOR not available", yellow);
          if (yes) {
            // const label1 = new Label().center();

            const a1 = audio1.play();
            const a2 = audio2.play();
            const a3 = audio3.play();

            // F.on("deviceorientation", (e) => {
            Ticker.add(() => {
              // label1.text = decimals(e.rotation.y, 2);
              // ball1.loc(W / 2 + e.rotation.y * 10, H / 2);
              if (ball1.x > W / 2) {
                a1.volume = 0.1;
                a2.volume = 0;
                a3.volume = 0;
              } else if (ball1.x > 600 && ball1.x < 700) {
                a3.volume = 0.1;
                a1.volume = 0;
                a2.volume = 0;
              } else {
                a1.volume = 0;
                a2.volume = 0.1;
                a3.volume = 0;
              }

              if (ball2.y > 2000) {
                if (!tone) {
                  tone = synth.tone({
                    volume: 2,
                    note: "C1",
                    shape: SQUARE,

                    wahAmount: 3000,
                    wahRate: 0.5,
                    wahThroat: 10,
                    wahNote: "A5",
                    wahShape: SINE,

                    vibratoAmount: 1000,
                    vibratoRate: 2,
                    vibratoShape: SINE,
                  });
                }
              } else if (ball2.y < 500) {
                if (!tone) {
                  tone = synth.tone({
                    volume: 2,
                    note: "A1",
                    shape: SQUARE,

                    tremeloAmount: 3000,
                    tremeloRate: 0.5,
                    tremeloThroat: 10,
                    tremeloNote: "A5",
                    tremeloShape: SINE,

                    wahAmount: 3000,
                    wahRate: 0.5,
                    wahThroat: 10,
                    wahNote: "A5",
                    wahShape: SINE,
                  });
                }
              } else {
                if (tone) {
                  tone.pause();
                  tone = null;
                }
              }
              S.update();
            });

            F.on("devicemotion", (e) => {
              label2.text = decimals(e.acceleration.x, 2);
              ball2.loc(W / 2 + e.acceleration.y * 10, H);
              if (ball2.x > W / 2) {
                s1.volume = 0;
                s2.volume = 1;
              } else {
                s1.volume = 1;
                s2.volume = 0;
              }
              S.update();
            });
          } else {
            errorPane.show();
          }
          S.update();
        }

        //Tiles for visual effects
        const scope = new Container(1290, 2896).pos(0, 0, CENTER);
        var backing = new Rectangle(scope.width, scope.height, clear).addTo(
          scope
        );
        var backing = new Circle(
          (scope.width / 2) * 0.95,
          new RadialColor(
            ["white", "coral".toAlpha(0.5)],
            [0, 1],
            0,
            0,
            (scope.width / 2) * 0.95,
            0,
            0,
            0
          ),
          grey
        ).center(scope);

        const mouthTile = new Circle(180, "coral", "blue")
          .pos(110, H - 650)
          .cur();
        const barTile = new Circle(180, "coral", "blue")
          .pos(560, H - 650)
          .cur();
        const circleTile = new Circle(180, "coral", "blue")
          .pos(1010, H - 650)
          .cur();

        const mouthLabel = new Label("Mouth", 30, "Arial", "white").center(
          mouthTile
        );
        const barLabel = new Label("Bar", 30, "Arial", "white").center(barTile);
        const circleLabel = new Label("Circle", 30, "Arial", "white").center(
          circleTile
        );

        let barSoundWave = new SoundWave(50, tone);
        let barWave;

        let isBarWaveActive = false;

        barTile.on("click", () => {
          if (!isBarWaveActive) {
            synth.wave = barSoundWave;
            startBarWave();
          } else {
            // Code to stop the bar wave or switch to a different wave
            synth.wave = null; // or any default wave
            // stopBarWave(); // if you have a function to stop the bar wave
          }

          // Toggle the state
          isBarWaveActive = !isBarWaveActive;
        });

        function startBarWave() {
          if (barWave) return;

          barWave = new SoundWave(50, tone);
          barWave.on("ready", function () {
            var bars = new Container(scope.width, scope.height)
              .addTo(scope)
              .setMask(backing);
            var width = bars.width;
            var gap = 3;
            // we can use barWave.num to tell us how many bars to make
            loop(barWave.num, function (i, total) {
              // make each bar
              var bar = new Rectangle(width / total - gap, 300, "coral");
              // move the bar over a little each time and set the registration point to the bottom
              bar
                .addTo(bars)
                .mov((i * width) / total, bars.height / 2)
                .reg(0, 150);
            });
            Ticker.add(function () {
              var data = barWave.calculate();
              // loop throught the bars and set the height of the bar to the associated barWave data
              // we multiply by 2 to magnify the data a little
              loop(bars, function (bar, i) {
                bar.heightOnly = data[i] * 600;
              });
            });
          });
        }

        let mouthSoundWave = new SoundWave(50, tone);
        let mouthWave;
        mouthTile.on("click", () => {
          synth.wave = mouthSoundWave;
          startMouthWave();
        });

        function startMouthWave() {
          if (mouthWave) return;

          mouthWave = new SoundWave(50, tone);
          mouthWave.on("ready", function () {
            var mouths = new Container(scope.width, scope.height)
              .addTo(scope)
              .setMask(backing);
            var width = mouths.width;
            var gap = 3;
            // we can use mouthWave.num to tell us how many mouths to make
            loop(mouthWave.num, function (i, total) {
              // make each mouth
              var mouth = new Blob({
                color: red,
                borderColor: pink,
                borderWidth: 30,
                showControls: false,
                points: [
                  [-5.9, 31.5, 0, 0, -38.2, -45.5, 35.6, -46.4, "free"],
                  [100.8, 32.9, 0, 0, 0, 0, 0, 0, "none"],
                  [52.3, 86.5, 0, 0, 32.8, -12.6, -32.8, 12.6, "mirror"],
                  [-50.6, 88.2, 0, 0, 29.4, 12.6, -33.1, -14.1, "mirror"],
                  [-106.7, 39.6, 0, 0, 0, 0, 0, 0, "none"],
                ],
              });
              // move the mouth over a little each time and set the registration point to the bottom
              mouth
                .addTo(mouths)
                .mov((i * width) / total, mouths.height / 2)
                .reg(0, 150);
            });
            Ticker.add(function () {
              var data = mouthWave.calculate();
              // loop throught the mouths and set the height of the mouth to the associated mouthWave data
              // we multiply by 2 to magnify the data a little
              loop(mouths, function (mouth, i) {
                mouth.heightOnly = data[i] * 600;
              });
            });
          });
        }

        let circleSoundWave = new SoundWave(50, tone);
        let circleWave;
        circleTile.on("click", () => {
          synth.wave = circleSoundWave;
          startCircleWave();
        });

        function startCircleWave() {
          if (circleWave) return;

          circleWave = new SoundWave(50, tone);
          circleWave.on("ready", function () {
            var circles = new Container(scope.width, scope.height)
              .addTo(scope)
              .setMask(backing);
            var width = circles.width;
            var gap = 3;
            // we can use circleWave.num to tell us how many circles to make
            loop(circleWave.num, function (i, total) {
              // make each circle
              var circle = new Circle(45, "#86b6db".toAlpha(0.6), "#86b6db".toAlpha(0.5));
              // move the circle over a little each time and set the registration point to the bottom
              circle
                .addTo(circles)
                .mov((i * width) / total, circles.height / 2)
                .reg(0, 150);
            });
            Ticker.add(function () {
              var data = circleWave.calculate();
              // loop throught the circles and set the height of the circle to the associated circleWave data
              // we multiply by 2 to magnify the data a little
              loop(circles, function (circle, i) {
                circle.heightOnly = data[i] * 600;
              });
            });
          });
        }

        //tiles for different sound effects
        const wahTile = new Rectangle(300, 300, "coral").pos(150, 300).cur();
        const vibratoTile = new Rectangle(300, 300, "coral")
          .pos(600, 300)
          .cur();
        const tremeloTile = new Rectangle(300, 300, "coral")
          .pos(1050, 300)
          .cur();
        const wahLabel = new Label("Wah", 30, "Arial", "white").center(wahTile);
        const vibratoLabel = new Label("Vibrato", 30, "Arial", "white").center(
          vibratoTile
        );
        const tremeloLabel = new Label("Tremelo", 30, "Arial", "white").center(
          tremeloTile
        );
        wahTile.on("click", () => {
          tone = synth.tone({
            volume: 2,
            note: "C1",
            shape: SQUARE,
            wahAmount: 3000,
            wahRate: 0.5,
            wahThroat: 10,
            wahNote: "A5",
            wahShape: SINE,
          });
        });

        vibratoTile.on("click", () => {
          tone = synth.tone({
            volume: 2,
            note: "C1",
            shape: SQUARE,
            vibratoAmount: 1000,
            vibratoRate: 2,
            vibratoShape: SINE,
          });
        });

        tremeloTile.on("click", () => {
          tone = synth.tone({
            volume: 2,
            note: "C1",
            shape: SQUARE,
            tremeloAmount: 3000,
            tremeloRate: 0.5,
            tremeloThroat: 10,
            tremeloNote: "A5",
            tremeloShape: SINE,
          });
        });
      } //end ready
    </script>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
  </head>
  <body></body>
</html>
